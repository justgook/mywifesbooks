---
import { Image } from 'astro:assets';

const { 
  books = [], 
  currentPage = 1, 
  totalPages = 1, 
  enableVirtualScroll = false, 
  tag = null, 
  genre = null, 
  series = null, 
  totalCount = 0, 
  pageSize = 12,
  isMainBooksPage = false 
} = Astro.props;

const placeholdersBefore = (currentPage - 1) * pageSize;
const booksAfter = totalCount - (currentPage * pageSize);
const placeholdersAfter = Math.max(0, booksAfter);
---

<div class="space-y-8">
  <div id="books-grid-container" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-6 gap-4">
    
    {enableVirtualScroll && placeholdersBefore > 0 && (
      <>
        {Array.from({ length: placeholdersBefore }, (_, i) => {
          const page = Math.floor(i / pageSize) + 1;
          const indexInPage = i % pageSize;
          return (
            <div 
              class="book-placeholder" 
              data-page={page}
              data-index={indexInPage}
            >
              <div class="aspect-[1/1.4] relative overflow-hidden bg-gradient-to-br from-blue-100 to-blue-200 dark:from-blue-900 dark:to-blue-800"></div>
            </div>
          );
        })}
      </>
    )}
    
    <div id="page-start" class="col-span-full h-0" style="scroll-margin-top: 0;"></div>
    
    {books.length > 0 ? books.map((book) => (
      <a href={`/books/${book.slug}`} class="block group relative book-card" data-page={currentPage}>
        <div class="aspect-[1/1.4] relative overflow-hidden">
          <Image
            src={book.data.image}
            alt={book.data.title}
            class="absolute inset-0 w-full h-full object-cover"
            loading={enableVirtualScroll ? "lazy" : "eager"}
          />
          <div class="absolute inset-0 bg-black/30 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
            <div class="absolute bottom-0 left-0 right-0 p-4 bg-gradient-to-t from-black/80 to-transparent">
              <h2 class="text-lg font-bold text-white">{book.data.title}</h2>
              <p class="text-gray-200 text-sm">{book.data.author}</p>
              <div class="flex flex-wrap gap-1 mt-1">
                {book.data.tags.map((tag: string) => (
                  <span class="bg-gray-800/80 text-gray-200 text-xs font-medium px-2 py-0.5 rounded">
                    {tag}
                  </span>
                ))}
              </div>
              {book.data.read && (
                <span class="bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 text-sm font-medium px-2.5 py-0.5 rounded mt-2 inline-block">
                  Прочитано
                </span>
              )}
              {!book.data.read && (
                <span class="bg-red-100 dark:bg-red-800 text-red-800 dark:text-red-200 text-sm font-medium px-2.5 py-0.5 rounded mt-2 inline-block">
                  Не прочитано
                </span>
              )}
            </div>
          </div>
        </div>
      </a>
    )) : <p class="text-center text-gray-500">No books found</p>}
    
    {enableVirtualScroll && placeholdersAfter > 0 && (
      <>
        {Array.from({ length: placeholdersAfter }, (_, i) => {
          const page = currentPage + Math.floor(i / pageSize) + 1;
          const indexInPage = i % pageSize;
          return (
            <div 
              class="book-placeholder" 
              data-page={page}
              data-index={indexInPage}
            >
              <div class="aspect-[1/1.4] relative overflow-hidden bg-gradient-to-br from-blue-100 to-blue-200 dark:from-blue-900 dark:to-blue-800"></div>
            </div>
          );
        })}
      </>
    )}
  </div>

  {enableVirtualScroll && (
    <nav id="pagination-nav" class="flex justify-center items-center gap-4 py-8">
      {currentPage > 1 && (
        <a 
          href={isMainBooksPage ? `/books/${currentPage - 1}` : 
                tag ? `/tags/${tag}/${currentPage - 1}` :
                genre ? `/genres/${genre}/${currentPage - 1}` :
                series ? `/series/${series}/${currentPage - 1}` : '#'}
          class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition"
        >
          ← Previous
        </a>
      )}
      
      <span class="text-gray-700 dark:text-gray-300">
        Page {currentPage} of {totalPages}
      </span>
      
      {currentPage < totalPages && (
        <a 
          href={isMainBooksPage ? `/books/${currentPage + 1}` : 
                tag ? `/tags/${tag}/${currentPage + 1}` :
                genre ? `/genres/${genre}/${currentPage + 1}` :
                series ? `/series/${series}/${currentPage + 1}` : '#'}
          class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition"
        >
          Next →
        </a>
      )}
    </nav>
  )}
</div>

{enableVirtualScroll && (
  <div id="scroll-progress" class="fixed bottom-4 right-4 bg-black/80 text-white px-4 py-2 rounded-lg shadow-lg backdrop-blur-sm z-50">
    <span id="progress-text">Page {currentPage} / {totalPages}</span>
  </div>
)}

<style>
  @keyframes shimmer {
    0% {
      background-position: -200% 0;
    }
    100% {
      background-position: 200% 0;
    }
  }

  .book-placeholder > div {
    background: linear-gradient(
      90deg,
      rgba(191, 219, 254, 0.3) 0%,
      rgba(147, 197, 253, 0.5) 50%,
      rgba(191, 219, 254, 0.3) 100%
    );
    background-size: 200% 100%;
    animation: shimmer 2s ease-in-out infinite;
  }

  :global(.dark) .book-placeholder > div {
    background: linear-gradient(
      90deg,
      rgba(30, 58, 138, 0.3) 0%,
      rgba(30, 64, 175, 0.5) 50%,
      rgba(30, 58, 138, 0.3) 100%
    );
    background-size: 200% 100%;
    animation: shimmer 2s ease-in-out infinite;
  }
</style>

{enableVirtualScroll && (
  <script is:inline define:vars={{ currentPage, totalPages, pageSize, totalCount, tag, genre, series, isMainBooksPage }}>
    if (!window.virtualScrollInitialized) {
      window.virtualScrollInitialized = true;
      
      const state = {
        currentPage: currentPage,
        totalPages: totalPages,
        pageSize: pageSize,
        totalCount: totalCount,
        tag: tag,
        genre: genre,
        series: series,
        isMainBooksPage: isMainBooksPage,
        loadedPages: new Set([currentPage]),
        loading: false,
        observer: null
      };

      const removePaginationNav = () => {
        const nav = document.getElementById('pagination-nav');
        if (nav) nav.remove();
      };

      const scrollToPageStart = () => {
        const anchor = document.getElementById('page-start');
        if (anchor) {
          setTimeout(() => {
            anchor.scrollIntoView({ behavior: 'instant', block: 'start' });
          }, 10);
        }
      };

      const createBookCard = (book, pageNumber) => {
        const a = document.createElement('a');
        a.href = `/books/${book.slug}`;
        a.className = 'block group relative book-card';
        a.dataset.page = pageNumber.toString();

        const div = document.createElement('div');
        div.className = 'aspect-[1/1.4] relative overflow-hidden';

        const img = document.createElement('img');
        img.src = book.image.src;
        img.alt = book.title;
        img.className = 'absolute inset-0 w-full h-full object-cover';
        img.loading = 'lazy';

        const overlay = document.createElement('div');
        overlay.className = 'absolute inset-0 bg-black/30 opacity-0 group-hover:opacity-100 transition-opacity duration-300';

        const content = document.createElement('div');
        content.className = 'absolute bottom-0 left-0 right-0 p-4 bg-gradient-to-t from-black/80 to-transparent';

        const title = document.createElement('h2');
        title.className = 'text-lg font-bold text-white';
        title.textContent = book.title;

        const author = document.createElement('p');
        author.className = 'text-gray-200 text-sm';
        author.textContent = book.author;

        const tagsContainer = document.createElement('div');
        tagsContainer.className = 'flex flex-wrap gap-1 mt-1';

        if (book.tags) {
          book.tags.forEach(tag => {
            const tagSpan = document.createElement('span');
            tagSpan.className = 'bg-gray-800/80 text-gray-200 text-xs font-medium px-2 py-0.5 rounded';
            tagSpan.textContent = tag;
            tagsContainer.appendChild(tagSpan);
          });
        }

        const readStatus = document.createElement('span');
        readStatus.className = book.read 
          ? 'bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 text-sm font-medium px-2.5 py-0.5 rounded mt-2 inline-block'
          : 'bg-red-100 dark:bg-red-800 text-red-800 dark:text-red-200 text-sm font-medium px-2.5 py-0.5 rounded mt-2 inline-block';
        readStatus.textContent = book.read ? 'Прочитано' : 'Не прочитано';

        content.appendChild(title);
        content.appendChild(author);
        content.appendChild(tagsContainer);
        content.appendChild(readStatus);
        overlay.appendChild(content);
        div.appendChild(img);
        div.appendChild(overlay);
        a.appendChild(div);

        return a;
      };

      const loadPage = async (page) => {
        if (state.loadedPages.has(page) || state.loading) return;
        
        state.loading = true;

        try {
          let url;
          if (state.tag) {
            url = `/api/books-by-tag/${encodeURIComponent(state.tag)}/${page}.json`;
          } else if (state.genre) {
            url = `/api/books-by-genre/${encodeURIComponent(state.genre)}/${page}.json`;
          } else if (state.series) {
            url = `/api/books-by-series/${encodeURIComponent(state.series)}/${page}.json`;
          } else if (state.isMainBooksPage) {
            url = `/api/books/${page}.json`;
          }

          if (!url) return;

          const response = await fetch(url);
          const data = await response.json();

          if (data.books && data.books.length > 0) {
            const grid = document.getElementById('books-grid-container');
            if (!grid) return;

            const placeholders = grid.querySelectorAll(`.book-placeholder[data-page="${page}"]`);
            
            data.books.forEach((book, index) => {
              if (placeholders[index]) {
                const bookCard = createBookCard(book, page);
                placeholders[index].replaceWith(bookCard);
              }
            });

            state.loadedPages.add(page);
            
            // Attach click handlers to newly loaded books
            attachBookClickHandlers();
          }
        } catch (error) {
          console.error('Error loading page:', page, error);
        } finally {
          state.loading = false;
        }
      };

      const setupIntersectionObserver = () => {
        const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const placeholder = entry.target;
              const page = parseInt(placeholder.dataset.page);
              if (!isNaN(page)) {
                loadPage(page);
              }
            }
          });
        }, {
          rootMargin: '800px',
          threshold: 0.01
        });

        const placeholders = document.querySelectorAll('.book-placeholder');
        const pageGroups = {};
        
        // Group placeholders by page
        placeholders.forEach(placeholder => {
          const page = parseInt(placeholder.dataset.page);
          if (!pageGroups[page]) {
            pageGroups[page] = [];
          }
          pageGroups[page].push(placeholder);
        });
        
        // Observe first and last placeholder of each page
        const visiblePages = new Set();
        Object.keys(pageGroups).forEach(page => {
          const group = pageGroups[page];
          if (group.length > 0) {
            observer.observe(group[0]); // First placeholder
            if (group.length > 1) {
              observer.observe(group[group.length - 1]); // Last placeholder
            }
            
            // Check if any placeholders are initially visible
            group.forEach(placeholder => {
              const rect = placeholder.getBoundingClientRect();
              if (rect.top < window.innerHeight && rect.bottom > 0) {
                visiblePages.add(parseInt(page));
              }
            });
          }
        });
        
        // Load initially visible pages
        visiblePages.forEach(page => {
          if (!state.loadedPages.has(page)) {
            loadPage(page);
          }
        });

        state.observer = observer;
      };

      const updateURL = () => {
        const grid = document.getElementById('books-grid-container');
        if (!grid) return;

        const viewportMiddle = window.scrollY + window.innerHeight / 2;
        
        // Check both book cards and placeholders to determine page
        const allItems = grid.querySelectorAll('.book-card, .book-placeholder');
        
        let detectedPage = currentPage; // Use initial page from props
        
        allItems.forEach(item => {
          const rect = item.getBoundingClientRect();
          const itemTop = rect.top + window.scrollY;
          
          if (itemTop < viewportMiddle) {
            const page = parseInt(item.dataset.page);
            if (!isNaN(page)) {
              detectedPage = page;
            }
          }
        });

        if (detectedPage !== state.currentPage) {
          state.currentPage = detectedPage;
          
          const basePath = state.isMainBooksPage ? '/books' :
                          state.tag ? `/tags/${state.tag}` :
                          state.genre ? `/genres/${state.genre}` :
                          state.series ? `/series/${state.series}` : '/books';
          
          history.replaceState(null, '', `${basePath}/${detectedPage}/`);
          
          const progressText = document.getElementById('progress-text');
          if (progressText) {
            progressText.textContent = `Page ${detectedPage} / ${state.totalPages}`;
          }
        }
      };

      const attachBookClickHandlers = () => {
        const bookLinks = document.querySelectorAll('.book-card');
        bookLinks.forEach(link => {
          if (!link.dataset.handlerAttached) {
            link.dataset.handlerAttached = 'true';
            link.addEventListener('click', () => {
              // Force immediate URL update to capture current position
              updateURL();
              sessionStorage.setItem('scrollPage', state.currentPage.toString());
              sessionStorage.setItem('scrollPosition', window.scrollY.toString());
            });
          }
        });
      };

      let scrollTimeout;
      window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(updateURL, 50);
      });

      removePaginationNav();
      scrollToPageStart();
      setupIntersectionObserver();
      attachBookClickHandlers();
    }
  </script>
)}
